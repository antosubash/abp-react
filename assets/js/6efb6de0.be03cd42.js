"use strict";(self.webpackChunkabp_react=self.webpackChunkabp_react||[]).push([[1769],{7359:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"fundamentals/authentication","title":"Authentication System","description":"ABP React implements a comprehensive authentication system using OpenID Connect with PKCE (Proof Key for Code Exchange) flow. This guide explains how the authentication works, from login to session management.","source":"@site/docs/fundamentals/authentication.md","sourceDirName":"fundamentals","slug":"/fundamentals/authentication","permalink":"/abp-react/docs/fundamentals/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/antosubash/abp-react/tree/main/docs/docs/fundamentals/authentication.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Architecture Overview","permalink":"/abp-react/docs/fundamentals/architecture"},"next":{"title":"Middleware","permalink":"/abp-react/docs/fundamentals/middleware"}}');var t=s(4848),o=s(8453);const r={sidebar_position:2},a="Authentication System",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Authentication Flow",id:"authentication-flow",level:2},{value:"1. Login Process",id:"1-login-process",level:3},{value:"Step 1: User Initiates Login",id:"step-1-user-initiates-login",level:4},{value:"Step 2: Authorization Request",id:"step-2-authorization-request",level:4},{value:"Step 3: User Authentication",id:"step-3-user-authentication",level:4},{value:"Step 4: Authorization Code Exchange",id:"step-4-authorization-code-exchange",level:4},{value:"2. Session Management",id:"2-session-management",level:3},{value:"Iron Session Configuration",id:"iron-session-configuration",level:4},{value:"Session Data Structure",id:"session-data-structure",level:4},{value:"Client-Side Session Access",id:"client-side-session-access",level:4},{value:"3. Token Management",id:"3-token-management",level:3},{value:"Automatic Token Refresh",id:"automatic-token-refresh",level:4},{value:"Token Expiration Check",id:"token-expiration-check",level:4},{value:"Multi-Tenancy Integration",id:"multi-tenancy-integration",level:2},{value:"Tenant Selection",id:"tenant-selection",level:3},{value:"Middleware Protection",id:"middleware-protection",level:3},{value:"API Integration",id:"api-integration",level:2},{value:"Automatic Token Injection",id:"automatic-token-injection",level:3},{value:"Proxy API Routes",id:"proxy-api-routes",level:3},{value:"Logout Process",id:"logout-process",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Environment Variables",id:"environment-variables",level:3},{value:"Client Configuration",id:"client-configuration",level:3},{value:"Security Features",id:"security-features",level:2},{value:"PKCE (Proof Key for Code Exchange)",id:"pkce-proof-key-for-code-exchange",level:3},{value:"Secure Session Storage",id:"secure-session-storage",level:3},{value:"Token Security",id:"token-security",level:3},{value:"Multi-Tenant Security",id:"multi-tenant-security",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"1. Authentication Redirect Loop",id:"1-authentication-redirect-loop",level:4},{value:"2. Token Refresh Failures",id:"2-token-refresh-failures",level:4},{value:"3. API Authorization Errors",id:"3-api-authorization-errors",level:4},{value:"Debug Mode",id:"debug-mode",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Secure Configuration",id:"1-secure-configuration",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Route Protection",id:"3-route-protection",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"authentication-system",children:"Authentication System"})}),"\n",(0,t.jsx)(n.p,{children:"ABP React implements a comprehensive authentication system using OpenID Connect with PKCE (Proof Key for Code Exchange) flow. This guide explains how the authentication works, from login to session management."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The authentication system in ABP React is built around:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OpenID Connect (OIDC)"})," with PKCE flow for secure authentication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Iron Session"})," for server-side session management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Redis"})," for distributed session storage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JWT tokens"})," for API authorization"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-tenancy"})," support with tenant-aware authentication"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"authentication-flow",children:"Authentication Flow"}),"\n",(0,t.jsx)(n.h3,{id:"1-login-process",children:"1. Login Process"}),"\n",(0,t.jsx)(n.p,{children:"The login process follows the OpenID Connect authorization code flow with PKCE:"}),"\n",(0,t.jsx)(n.h4,{id:"step-1-user-initiates-login",children:"Step 1: User Initiates Login"}),"\n",(0,t.jsxs)(n.p,{children:["When a user clicks the login button, they are redirected to ",(0,t.jsx)(n.code,{children:"/auth/login"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/components/Login.tsx\nconst Login = () => {\n  const handleLogin = () => {\n    window.location.href = '/auth/login'\n  }\n  // ...\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"step-2-authorization-request",children:"Step 2: Authorization Request"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"/auth/login"})," route handler generates PKCE parameters and redirects to ABP's authorization endpoint:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// src/app/auth/login/route.ts\nexport async function GET() {\n  const session = await getSession()\n  \n  // Generate PKCE parameters\n  let code_verifier = client.randomPKCECodeVerifier()\n  let code_challenge = await client.calculatePKCECodeChallenge(code_verifier)\n  \n  // Get OpenID configuration\n  const openIdClientConfig = await getClientConfig()\n  let tenantId = session.tenantId\n\n  // Build authorization URL with parameters\n  let parameters: Record<string, string> = {\n    "redirect_uri": clientConfig.redirect_uri,\n    "scope": clientConfig.scope!,\n    code_challenge,\n    "code_challenge_method": "S256",\n    "__tenant": tenantId,\n  }\n\n  // Store PKCE verifier in session\n  let redirectTo = client.buildAuthorizationUrl(openIdClientConfig, parameters)\n  session.code_verifier = code_verifier\n  session.state = state\n  await session.save()\n  \n  return Response.redirect(redirectTo.href)\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"step-3-user-authentication",children:"Step 3: User Authentication"}),"\n",(0,t.jsx)(n.p,{children:"The user is redirected to ABP's login page where they enter their credentials. After successful authentication, ABP redirects back to the configured callback URL."}),"\n",(0,t.jsx)(n.h4,{id:"step-4-authorization-code-exchange",children:"Step 4: Authorization Code Exchange"}),"\n",(0,t.jsxs)(n.p,{children:["The callback is handled by ",(0,t.jsx)(n.code,{children:"/auth/openiddict/route.ts"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/app/auth/openiddict/route.ts\nexport async function GET(request: NextRequest) {\n  const session = await getSession()\n  const openIdClientConfig = await getClientConfig()\n  \n  // Exchange authorization code for tokens\n  const tokenSet = await client.authorizationCodeGrant(openIdClientConfig, currentUrl, {\n    pkceCodeVerifier: session.code_verifier,\n    expectedState: session.state\n  })\n  \n  const { access_token, refresh_token } = tokenSet\n  \n  // Get user information\n  const userinfo = await client.fetchUserInfo(openIdClientConfig, access_token, sub)\n  \n  // Update session\n  session.isLoggedIn = true\n  session.access_token = access_token\n  session.userInfo = {\n    sub: userinfo.sub,\n    name: userinfo.given_name!,\n    email: userinfo.email!,\n    email_verified: userinfo.email_verified!,\n  }\n  \n  await session.save()\n  \n  // Store tokens in Redis for distributed access\n  const redisSessionData = {\n    access_token: access_token,\n    refresh_token: refresh_token,\n  } as RedisSession\n  \n  const redis = createRedisInstance()\n  const redisKey = `session:${session.userInfo.sub}`\n  await redis.set(redisKey, JSON.stringify(redisSessionData))\n  await redis.quit()\n  \n  return Response.redirect(clientConfig.post_login_route)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-session-management",children:"2. Session Management"}),"\n",(0,t.jsx)(n.h4,{id:"iron-session-configuration",children:"Iron Session Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Sessions are managed using Iron Session with secure configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/sessionOptions.ts\nexport const sessionOptions: SessionOptions = {\n  password: process.env.SESSION_PASSWORD || 'complex_password_at_least_32_characters_long',\n  cookieName: 'abp-react-session-id',\n  cookieOptions: {\n    secure: process.env.NODE_ENV === 'production',\n  },\n  ttl: 60 * 60 * 24 * 7, // 1 week\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"session-data-structure",children:"Session Data Structure"}),"\n",(0,t.jsx)(n.p,{children:"The session contains comprehensive user and authentication data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/lib/session-utils.ts\nexport interface SessionData {\n  isLoggedIn: boolean\n  access_token?: string\n  code_verifier?: string\n  state?: string\n  userInfo?: {\n    sub: string\n    name: string\n    email: string\n    email_verified: boolean\n  }\n  tenantId?: string\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"client-side-session-access",children:"Client-Side Session Access"}),"\n",(0,t.jsxs)(n.p,{children:["Components use the ",(0,t.jsx)(n.code,{children:"useSession"})," hook to access session data:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/useSession.ts\nexport default function useSession(): UseQueryResult<SessionData, Error> {\n  return useQuery({\n    queryKey: [QueryNames.GetSession],\n    queryFn: async () => {\n      const response = await fetch('/session')\n      return (await response.json()) as SessionData\n    },\n    refetchOnWindowFocus: true\n  })\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-token-management",children:"3. Token Management"}),"\n",(0,t.jsx)(n.h4,{id:"automatic-token-refresh",children:"Automatic Token Refresh"}),"\n",(0,t.jsx)(n.p,{children:"The system automatically refreshes expired tokens:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/lib/actions.ts\nexport async function getSession(): Promise<IronSession<SessionData>> {\n  let session = await getIronSession<SessionData>(await cookies(), sessionOptions)\n  \n  try {\n    // Check if the access token is expired\n    if (session.access_token && isTokenExpired(session.access_token!)) {\n      const redisKey = `session:${session?.userInfo?.sub!}`\n      const redis = createRedisInstance()\n      const clientConfig = await getClientConfig()\n\n      // Retrieve session data from Redis\n      let redisSessionData = await redis.get(redisKey)\n      const parsedSessionData = JSON.parse(redisSessionData!) as RedisSession\n\n      // Refresh the access token using the refresh token\n      const tokenSet = await client.refreshTokenGrant(clientConfig, parsedSessionData.refresh_token!)\n      session.access_token = tokenSet.access_token\n      await session.save()\n\n      // Update Redis with the new session data\n      const newRedisSessionData = {\n        access_token: tokenSet.access_token,\n        refresh_token: tokenSet.refresh_token,\n      } as RedisSession\n      await redis.set(redisKey, JSON.stringify(newRedisSessionData))\n      await redis.quit()\n    }\n    return session\n  } catch (error) {\n    console.error('Error getting session:', error)\n    // Return default session on error\n    return session\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"token-expiration-check",children:"Token Expiration Check"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/lib/auth.ts\nexport const isTokenExpired = (token: string) => {\n  const decoded = jwtDecode(token!);\n  const expirationTime = decoded?.exp! * 1000;\n  const currentTime = new Date().getTime();\n  return expirationTime < currentTime\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"multi-tenancy-integration",children:"Multi-Tenancy Integration"}),"\n",(0,t.jsx)(n.h3,{id:"tenant-selection",children:"Tenant Selection"}),"\n",(0,t.jsx)(n.p,{children:"Before authentication, users must select their tenant:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/app/auth/set-tenant/route.ts\nexport async function GET() {\n  await setUpLayoutConfig()\n  const session = await getSession()\n  const host = (await headers()).get('host')\n\n  if (session.tenantId) {\n    return\n  }\n\n  try {\n    const { data } = await tenantGetTenantGuid({ query: { host: host! } })\n    session.tenantId = data ?? 'default'\n  } catch (error) {\n    console.error('Failed to fetch tenant GUID:', error)\n    session.tenantId = 'default'\n  }\n\n  await session.save()\n  redirect('/')\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"middleware-protection",children:"Middleware Protection"}),"\n",(0,t.jsx)(n.p,{children:"The middleware ensures users have a tenant selected:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/middleware.ts\nexport async function middleware(request: NextRequest): Promise<NextResponse | undefined> {\n  const session = await getIronSession<SessionData>(await cookies(), sessionOptions)\n\n  // Check if tenantId is present in the session\n  if (!session.tenantId && request.nextUrl.pathname !== '/auth/set-tenant') {\n    let redirectUrl = new URL('/auth/set-tenant', request.nextUrl.origin)\n    return NextResponse.redirect(redirectUrl)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"api-integration",children:"API Integration"}),"\n",(0,t.jsx)(n.h3,{id:"automatic-token-injection",children:"Automatic Token Injection"}),"\n",(0,t.jsx)(n.p,{children:"API requests automatically include authentication headers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/lib/auth.ts\nexport const setUpLayoutConfig = async () => {\n  APIClient.setConfig({\n    baseUrl: typeof window !== 'undefined' ? '' : process.env.NEXT_PUBLIC_API_URL!,\n  })\n  \n  APIClient.interceptors.request.use(async (options) => {\n    const session = await getSession()\n    options.headers.set('Authorization', `Bearer ${session.access_token}`)\n    options.headers.set('__tenant', session.tenantId ?? '')\n    return options\n  })\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"proxy-api-routes",children:"Proxy API Routes"}),"\n",(0,t.jsx)(n.p,{children:"API calls are proxied through Next.js routes to include authentication:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/app/api/[...slug]/route.ts\nexport async function handler(request: NextRequest) {\n  const session = await getSession()\n  \n  // Add authentication headers\n  headers.set('Authorization', `Bearer ${session.access_token}`)\n  headers.set('__tenant', session.tenantId ?? '')\n  \n  // Forward request to ABP backend\n  const response = await fetch(targetUrl, {\n    method: request.method,\n    headers,\n    body: request.body,\n  })\n  \n  return response\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"logout-process",children:"Logout Process"}),"\n",(0,t.jsx)(n.p,{children:"The logout process cleans up all session data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// src/app/auth/logout/route.ts\nexport async function GET() {\n  const session = await getSession()\n  const redis = createRedisInstance()\n  const redisKey = `session:${session.userInfo?.sub}`\n  \n  // Get session data from Redis\n  const redisSessionData = await redis.get(redisKey);\n  const parsedSessionData = JSON.parse(redisSessionData!) as RedisSession;\n  \n  // Build end session URL\n  const openIdClientConfig = await getClientConfig()\n  const endSessionUrl = client.buildEndSessionUrl(openIdClientConfig, {\n    post_logout_redirect_uri: clientConfig.post_logout_redirect_uri,\n    id_token_hint: parsedSessionData.access_token,\n  })\n  \n  // Clear session data\n  session.isLoggedIn = defaultSession.isLoggedIn\n  session.access_token = defaultSession.access_token\n  session.userInfo = defaultSession.userInfo\n  \n  // Remove from Redis\n  await redis.del(session?.userInfo?.sub!)\n  await session.save()\n  \n  return Response.redirect(endSessionUrl.href)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,t.jsx)(n.p,{children:"Configure authentication settings in your environment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-env",children:"# Application URLs\nNEXT_PUBLIC_APP_URL=http://localhost:3000\nNEXT_PUBLIC_API_URL=http://localhost:44300\n\n# OpenID Connect Configuration\nNEXT_PUBLIC_CLIENT_ID=your-client-id\nNEXT_PUBLIC_SCOPE=openid profile email phone roles\n\n# Session Security\nSESSION_PASSWORD=your-secure-session-password-at-least-32-characters\n\n# Redis Configuration (for distributed sessions)\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=your-redis-password\n"})}),"\n",(0,t.jsx)(n.h3,{id:"client-configuration",children:"Client Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["The OpenID client is configured in ",(0,t.jsx)(n.code,{children:"src/config.ts"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const clientConfig = {\n  url: process.env.NEXT_PUBLIC_API_URL,\n  audience: process.env.NEXT_PUBLIC_API_URL,\n  client_id: process.env.NEXT_PUBLIC_CLIENT_ID,\n  scope: process.env.NEXT_PUBLIC_SCOPE,\n  redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/auth/openiddict`,\n  post_logout_redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}`,\n  response_type: 'code',\n  grant_type: 'authorization_code',\n  post_login_route: `${process.env.NEXT_PUBLIC_APP_URL}`,\n  code_challenge_method: 'S256'\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"security-features",children:"Security Features"}),"\n",(0,t.jsx)(n.h3,{id:"pkce-proof-key-for-code-exchange",children:"PKCE (Proof Key for Code Exchange)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Prevents authorization code interception attacks"}),"\n",(0,t.jsx)(n.li,{children:"Uses SHA256 code challenge method"}),"\n",(0,t.jsx)(n.li,{children:"Generates secure random code verifiers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"secure-session-storage",children:"Secure Session Storage"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Iron Session with strong encryption"}),"\n",(0,t.jsx)(n.li,{children:"HttpOnly cookies in production"}),"\n",(0,t.jsx)(n.li,{children:"Configurable session TTL"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"token-security",children:"Token Security"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"JWT tokens stored securely server-side"}),"\n",(0,t.jsx)(n.li,{children:"Automatic token refresh before expiration"}),"\n",(0,t.jsx)(n.li,{children:"Secure token transmission via HTTPS"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"multi-tenant-security",children:"Multi-Tenant Security"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Tenant isolation at the authentication level"}),"\n",(0,t.jsx)(n.li,{children:"Tenant-specific token scoping"}),"\n",(0,t.jsx)(n.li,{children:"Secure tenant selection process"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,t.jsx)(n.h4,{id:"1-authentication-redirect-loop",children:"1. Authentication Redirect Loop"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Session configuration issues or tenant selection problems."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Check that ",(0,t.jsx)(n.code,{children:"SESSION_PASSWORD"})," is set correctly"]}),"\n",(0,t.jsx)(n.li,{children:"Verify tenant configuration"}),"\n",(0,t.jsx)(n.li,{children:"Clear browser cookies and try again"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-token-refresh-failures",children:"2. Token Refresh Failures"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Redis connection issues or expired refresh tokens."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check Redis connection configuration"}),"\n",(0,t.jsx)(n.li,{children:"Verify refresh token is being stored correctly"}),"\n",(0,t.jsx)(n.li,{children:"Check OpenID Connect configuration"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-api-authorization-errors",children:"3. API Authorization Errors"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cause"}),": Token not being included in requests or expired tokens."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Verify ",(0,t.jsx)(n.code,{children:"setUpLayoutConfig()"})," is called in layout"]}),"\n",(0,t.jsx)(n.li,{children:"Check API proxy configuration"}),"\n",(0,t.jsx)(n.li,{children:"Ensure proper error handling for token refresh"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"debug-mode",children:"Debug Mode"}),"\n",(0,t.jsx)(n.p,{children:"Enable debug logging for authentication:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Add to your layout or middleware\nif (process.env.NODE_ENV === 'development') {\n  console.log('Session:', session)\n  console.log('Token expired:', isTokenExpired(session.access_token))\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-secure-configuration",children:"1. Secure Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Use strong session passwords\nSESSION_PASSWORD=your-very-secure-password-with-at-least-32-characters\n\n// Enable secure cookies in production\ncookieOptions: {\n  secure: process.env.NODE_ENV === 'production',\n  httpOnly: true,\n  sameSite: 'strict'\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { data: session, error } = useSession()\n\nif (error) {\n  // Handle authentication errors\n  window.location.href = '/auth/login'\n}\n\nif (!session?.isLoggedIn) {\n  // Show login prompt\n  return <LoginPrompt />\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-route-protection",children:"3. Route Protection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Protect admin routes\nexport default function ProtectedPage() {\n  const { data: session, isLoading } = useSession()\n  \n  if (isLoading) return <Loader />\n  if (!session?.isLoggedIn) {\n    redirect('/auth/login')\n  }\n  \n  return <AdminContent />\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/fundamentals/api-integration",children:"API Integration"})})," - Learn how to make authenticated API calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/fundamentals/multi-tenancy",children:"Multi-tenancy"})})," - Understand multi-tenant authentication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/fundamentals/admin-interface",children:"Admin Interface"})})," - Explore the admin dashboard features"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/docs/fundamentals/permissions",children:"Permissions"})})," - Set up role-based access control"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"The authentication system provides a robust, secure foundation for your ABP React application with enterprise-grade features like multi-tenancy, automatic token refresh, and comprehensive session management."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);